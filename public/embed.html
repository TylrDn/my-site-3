<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>MacroSight Embed</title>
    <link rel="stylesheet" href="./styles.css" />
    <style>
      .loader {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        font-size: 1.2rem;
        color: var(--color-muted);
      }

      .loader::after {
        content: '';
        width: 20px;
        height: 20px;
        margin-left: 10px;
        border: 2px solid var(--color-border);
        border-top: 2px solid var(--color-accent);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    </style>
    <script src="./assets/origins-global.js" defer></script>
    <script>
      // Allowed parents that may embed this page (use your exact prod/staging origins)
      const ALLOWED_PARENTS = [
        'https://www.macrosight.net',
        'https://macrosight.netlify.app'
      ];

      // Use the single source of truth
      const patternToRegex =
        (window.__MYAPP__ && window.__MYAPP__.patternToRegex) ||
        ((p) => { throw new Error('patternToRegex not loaded'); });

      // Pre-build regexes for speed
      const PARENT_RX = ALLOWED_PARENTS.map(patternToRegex);

      // Keep a stable reference to the iframe you expect to talk to (if you control it),
      // otherwise enforce origin-only checks.
      let expectedSource = null;

      function isAllowedOrigin(origin) {
        try {
          const { hostname } = new URL(origin);
          return PARENT_RX.some((rx) => rx.test(hostname) || rx.test(origin));
        } catch {
          return false;
        }
      }

      // Minimal sanitizer: strips <script>, event attributes, javascript: URLs, <head>.
      // This is intentionally *restrictive*. Prefer DOMPurify if you decide to add it later.
      function sanitizeHtml(html) {
        const parser = new DOMParser();
        // Parse to a detached document (don’t trust until sanitized). MDN: DOMParser does not sanitize.
        const doc = parser.parseFromString(String(html), 'text/html');

        // Nuke <head> content & scripts
        const head = doc.querySelector('head');
        if (head) head.remove();

        doc.querySelectorAll('script, link[rel="preload"][as="script"]').forEach((n) => n.remove());

        // Remove inline handlers and javascript: URLs
        doc.querySelectorAll('*').forEach((el) => {
          [...el.attributes].forEach((attr) => {
            const name = attr.name.toLowerCase();
            const value = attr.value || '';
            if (name.startsWith('on')) el.removeAttribute(attr.name);
            if ((name === 'href' || name === 'src') && /^\s*javascript:/i.test(value)) {
              el.removeAttribute(attr.name);
            }
          });
        });

        // Only allow body children to be injected
        const frag = document.createDocumentFragment();
        [...doc.body.childNodes].forEach((n) => frag.appendChild(n));
        return frag;
      }

      // Trusted Types (best effort; requires CSP TrustedTypes policy to be fully enforced)
      const ttPolicy = window.trustedTypes?.createPolicy?.('appSanitizer', {
        createHTML: (s) => s
      });

      window.addEventListener('message', (event) => {
        if (!isAllowedOrigin(event.origin)) return; // MDN: always validate origin.

        // Optional: pin source after first valid message
        if (expectedSource && event.source !== expectedSource) return;
        if (!expectedSource) expectedSource = event.source;

        // Accept only strings (HTML) – reject objects to avoid prototype/JSON hijinks
        const payload = event.data;
        if (typeof payload !== 'string') return;

        // Sanitize and inject strictly into your known container
        const container = document.getElementById('embed-root');
        if (!container) return;

        // Clear any existing content/skeleton safely
        while (container.firstChild) container.removeChild(container.firstChild);

        const frag = sanitizeHtml(payload);
        container.appendChild(frag);
      });
    </script>
    <script defer src="./scripts/responsive-iframe.js"></script>
  </head>
  <body>
    <div id="embed-root"><div class="loader">Loading</div></div>
    <noscript>
      This page is meant to be embedded.
      <a href="home.html">Go to Home</a>
    </noscript>
    <div class="iframe-container" style="--iframe-aspect: 16/9">
      <iframe data-ri title="Embedded content"></iframe>
    </div>
    <script src="./mobile-nav.js" defer></script>
  </body>
</html>
